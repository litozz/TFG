<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
    <title>Algoritmos de Búsqueda en inteligencia artificial.</title>

    <style type="text/css">
        body{
            background:url("img/fondo.png");
            color: #090963;
        }
        html, body {
            font: 11pt arial;
        }

        h1 {
            font-size: 150%;
            margin: 5px 0;
        }

        h2 {
            font-size: 100%;
            margin: 5px 0;
        }

        table.view {
            width: 100%;
        }

        table td {
            vertical-align: top;
        }

        table table {
            background-color: #f5f5f5;
            border: 1px solid #e5e5e5;
        }

        table table td {
            vertical-align: middle;
        }

        input[type=text], pre {
            border: 1px solid lightgray;
        }

        pre {
            margin: 0;
            padding: 5px;
            font-size: 10pt;
        }

        .network_box {
            width: 100%;
            height: 400px;
            border: 1px solid lightgray;
        }

        .info_color_ini{color:red;}
		.info_color_fin{color:green;}


		#network-form-div{
			float:left;
			width: 65%;
			background-color: lightgray;
			border:5px solid;
			margin-right:2px;
			overflow: hidden;
		}

		#import-network-div{
			float:left;
			width: 30%;
			background-color: lightgray;
			border:5px solid;
			margin-left: 2px;
			clear: both;
		}

		#principal:after{
			content:"";
			clear:both;
			display: block;
		}

        #textarea-explanation,#textarea-openclosed{
            width: 100%;
            resize: none;
        }

        #network-form-div-node,#network-form-div-edge{
        	width: 50%; 
        	float: left;
        	padding-bottom: 100%;
        	margin-bottom: -100%;
        	border:1px dashed;
        }

        #network-form-div-edge{
        	width: 45%; 
        	float: right;
        	padding-bottom: 100%;
        	margin-bottom: -100%;
        }
        
        .desplegable{clear:both; font-weight: bold; cursor: pointer}
        .desplegable:hover a{background-color:#090963; color:white;}

        #col-network-data{width: 25%;}
        #col-network-draw{width: 75%;}
        #col-network-actual-estate{width: 60%;}
		#col-network-select-algoritm{width: 40%;}
		#col-network-control-buttons{width: 40%;}

        #footer{
            position: fixed;
            bottom:0;
            left:0;
            display: inline-block;
            text-align: center;
            background-color: #090963;
            width: 100%;
            color:white;
            padding: 10px 0;
        }
    </style>

    <script type="text/javascript" src="vis-4.18.1/dist/vis.js"></script>
    <script src="./jquery.min.js"></script><!--importar jQuery-->
    <script type="text/javascript" src="./algorithms.js"></script> <!-- biblioteca algoritmos -->
    <!--<link href="../../../dist/vis-network.min.css" rel="stylesheet" type="text/css"/>-->



    <!--SCRIPT PARA DIBUJAR EL GRAFO-->
    <script type="text/javascript">
        var nodes, edges, network;
        //var adj_mat=[];
        var node_heuristics=[];
        var node_ids;
		var edge_ids;
		var initial_node_id;
		var end_nodes_id=[];
		var initial_exists=false;


		function resetNodeEntry(){
			$("#node-id").val("");
            $("#node-heuristic").val("");
            
            if(!initial_exists){
            	$("#cb_initial_node").attr("disabled", false);
            	$("#cb_initial_node").attr("checked", false);
            }

            $("#cb_final_node").attr("disabled", false);
            $("#cb_final_node").attr("checked", false);
		}

		function resetEdgeEntry(){
			$("#edge-from").val("");
            $("#edge-to").val("");
            $("#edge-cost").val("");
            $("#cb_directed_edge").attr("disabled", false);
            $("#cb_directed_edge").attr("checked", false);
		}

		function resetForm(){
			resetNodeEntry();
            resetEdgeEntry();
		}

		$(document).ready(function(){
            //Resetear el formulario de importar cuando se recarga la pagina:
            $("#import-network-input").val("");
            //Resetear el formulario de dibujar cuando se recarga la pagina:
            /*$("#node-id").val("");
            $("#node-heuristic").val("");
            $("#cb_initial_node").attr("disabled", false);
            $("#cb_initial_node").attr("checked", false);

            $("#edge-from").val("");
            $("#edge-to").val("");
            $("#edge-cost").val("");
            $("#cb_directed_edge").attr("disabled", false);
            $("#cb_directed_edge").attr("checked", false);*/
            resetForm();
            //FIN RESETEO FORMULARIO
			$("#resolution").hide();
			$("#import-network-btn").prop("disabled",true);
			$("#import-network-input").bind("change",readSingleFile);

			$("#edit-network").hide();
			$("#heuristic-generation").hide();


			$("#network-form-div").hide();
			$("#import-network-div").hide();


			$("#despliegue_dibujar").click(function(){
				$("#network-form-div").toggle("slow");
			});

			$("#despliegue_importar").click(function(){
				$("#import-network-div").toggle("slow");
			});
		});


		//Variables que controlan el cambio de propiedades de los nodos
		var is_initial_selected=false;
		var selected_node;
		var eventos_creados=false;



		function createNetworkEvents(network){
			network.on("click", function (params) {
        		params.event = "[original event]";



        		if(params.nodes[0]!=null){//He seleccionado un nodo del grafo
        			resetEdgeEntry();

        			//RELLENO LOS DATOS DEL NODO EN EL FORMULARIO
	        		$("#node-id").val(params.nodes[0]);
	        		var heur_nodo=node_heuristics[ node_ids.indexOf(params.nodes[0]) ]
	        		$("#node-heuristic").val(heur_nodo);

	        		if (initial_node_id==params.nodes[0]){
	        			$("#cb_initial_node").attr("checked", true);
	        			$("#cb_final_node").attr("checked", false);
	        		}else if(end_nodes_id.includes(params.nodes[0])){
	        			$("#cb_initial_node").attr("checked", false);
	        			$("#cb_final_node").attr("checked", true);
	        		}else{
	        			$("#cb_initial_node").attr("checked", false);
	        			$("#cb_final_node").attr("checked", false);
	        		}


        			if(is_initial_selected){//El nodo inicial estaba seleccionado y vamos a cambiarlo
        				if(end_nodes_id.includes(params.nodes[0])){
        					alert("Un nodo final no puede ponerse como inicial.");
        				}else{
	        				//Pongo el nuevo nodo inicial a rojo
	        				nodes.update({
		                    	id: params.nodes[0],
		                    	color: "red"//{background:'red', border:'red',highlight:{background:'red',border:'red'},hover: {background: 'red',border: 'red'}}
		                	});

	        				//El nodo anterior lo reseteo a los colores por defecto
	        				nodes.update({
	        					id: initial_node_id,
	        					color: {background:'#97C2FC', border:'#2B7CE9',highlight:{background:'#D2E5FF',border:'#2B7CE9'}}
	        				});

	        				//Establezco el nuevo nodo inicial
		                	initial_node_id=params.nodes[0];
		                	//Digo que ya el inicial no esta seleccionado
		                	is_initial_selected=false;

		                	$("#cb_initial_node").attr("checked", true);
	        				$("#cb_final_node").attr("checked", false);
	                	}
        			}else if(params.nodes[0]==initial_node_id){//Se ha clicado en el nodo inicial
        				if(is_initial_selected){ //Se clica en el nodo inicial por dos veces,
        					nodes.update({
		                    	id: initial_node_id,
		                    	color: "red"//{background:'red', border:'red',highlight:{background:'red',border:'red'},hover: {background: 'red',border: 'red'}}
		                	});
		                	initial_node_id=initial_node_id;
		                	is_initial_selected=false;

		                	
        				}else{//Se clica en el nodo inicial por primera vez
		        			nodes.update({
		                    	id: initial_node_id,
		                    	color: "yellow"
		                	});
		                	is_initial_selected=true;
    					}
        			}
        			
        			printInfo();
        		}else if(params.edges[0]!=null){//He seleccionado una arista
        			resetNodeEntry();
    				var edge_data = edges.get({
					  fields: ['id','from','to','label','arrows'],    // output the specified fields only
					});
					
					for(var i=0;i<edge_data.length;i++){
						if(edge_data[i].id == params.edges[0]){
							$("#edge-from").val(edge_data[i].from);
							$("#edge-to").val(edge_data[i].to);
							$("#edge-cost").val(Number(edge_data[i].label));
							if(edge_data[i].arrows=="to"){
								$("#cb_directed_edge").attr("checked", true);
							}

							break;
						}
					}
    			}else{
    				nodes.update({
                		id: initial_node_id,
                		color: "red"//{background:'red', border:'red',highlight:{background:'red',border:'red'},hover: {background: 'red',border: 'red'}}
	            	});
	            	initial_node_id=initial_node_id;
	            	is_initial_selected=false;

	            	resetForm();
    			}
    		});





			//Con doble click se ponen los nodos finales
			network.on("doubleClick", function (params) {
        		params.event = "[original event]";
        		
        		if(params.nodes[0]==initial_node_id){
        			alert("El nodo inicial no puede ser final.");
        		}else{
        			//Si el nodo ya era final, deja de ser final.
        			if(end_nodes_id.includes(params.nodes[0])){
        				var index=end_nodes_id.indexOf(params.nodes[0]);
        				end_nodes_id.splice(index,1);
        				nodes.update({
        					id: params.nodes[0],
        					color: {background:'#97C2FC', border:'#2B7CE9',highlight:{background:'#D2E5FF',border:'#2B7CE9'}}
        				});
        			}else if(params.nodes[0]!=null){//Si el nodo no es final, pasa a ser final
        				end_nodes_id.push(params.nodes[0]);
        				nodes.update({
                    		id: params.nodes[0],
                    		color:  "green"
                		});
        			}
        		}

        		printInfo();
        	});
		
			eventos_creados=true;
			//alert("Eventos creados");

		}




		

        // convenience method to stringify a JSON object
        function toJSON(obj) {
            return JSON.stringify(obj, null, 4);
        }

        function addNode() {
            /*Estructura de los nodos:
                id: identificador del nodo
                label: lo que aparece en pantalla, el id del nodo junto con su función heurística
                color: color del nodo
                title: en este apartado guardaremos la heuristica
            */



        	if(document.getElementById('node-id').value==""){
        		alert("El id del nodo no puede estar vacio");
        	}else{
	            try {
                    heur=Number(document.getElementById('node-heuristic').value)
	                if(document.getElementById('cb_initial_node').checked && !document.getElementById('cb_final_node').checked){ //Si es nodo inicial
	                	initial_node_id=document.getElementById('node-id').value;
	                	document.getElementById('cb_initial_node').checked=false;
	                	nodes.add({
	                    	id: document.getElementById('node-id').value,
	                    	label: document.getElementById('node-id').value+"\n(H="+heur+")",
                            title: heur, //En title guardaremos la heuristica del nodo
	                    	color: "red"
	                    	//label: document.getElementById('node-label').value
	                	});
	                	initial_exists=true;
	                	document.getElementById('cb_initial_node').disabled=true;
	                


                    }else if(!document.getElementById('cb_initial_node').checked && document.getElementById('cb_final_node').checked){
	                	end_nodes_id.push(document.getElementById('node-id').value);

	                	nodes.add({
	                    	id: document.getElementById('node-id').value,
	                    	label: document.getElementById('node-id').value+"\n(H="+heur+")",
                            title: heur,
                            color: "green"
	                    	//label: document.getElementById('node-label').value
	                	});
	                

                    }else if(document.getElementById('cb_initial_node').checked && document.getElementById('cb_final_node').checked){
	                	alert("Un nodo no puede ser inicial y final a la vez");     
	                

                    }else{
	                	nodes.add({
	                   		id: document.getElementById('node-id').value,
	                    	label: document.getElementById('node-id').value+"\n(H="+heur+")",
                            title: heur
	                    	//label: document.getElementById('node-label').value
	                	});
	                }
	                node_heuristics.push(Number(document.getElementById('node-heuristic').value))
	                document.getElementById('node-id').value=null;
	            

	                if(!eventos_creados){
			        	createNetworkEvents(network);	
			        }
			        printInfo();

	            }
	            catch (err) {
	                alert(err);
	                if(initial_exists){
	                	document.getElementById('cb_initial_node').disabled=true;
	                }else{
	                	document.getElementById('cb_initial_node').disabled=false;
	                }
	            }
	        }

	       
        }






        function updateNode() {
            /*try {
            	heur=Number(document.getElementById('node-heuristic').value)
                nodes.update({
                	nodes.add({
                    	id: document.getElementById('node-id').value,
                    	label: document.getElementById('node-id').value+"\n(H="+heur+")",
                        title: heur, //En title guardaremos la heuristica del nodo
                    	color: "red"
                    	//label: document.getElementById('node-label').value
                	});

                    id: document.getElementById('node-id').value,
                    label: document.getElementById('node-id').value
                    //label: document.getElementById('node-label').value
                });
            }
            catch (err) {
                alert(err);
            }*/
            if(document.getElementById('node-id').value==""){ //El id del nodo esta vacio
        		alert("El id del nodo no puede estar vacio");
        	}else{
	            try {
                    heur=Number(document.getElementById('node-heuristic').value)
	                if(document.getElementById('cb_initial_node').checked && !document.getElementById('cb_final_node').checked){ //Si es nodo inicial
	                	initial_node_id=document.getElementById('node-id').value;
	                	document.getElementById('cb_initial_node').checked=false;
	                	nodes.update({
	                    	id: document.getElementById('node-id').value,
	                    	label: document.getElementById('node-id').value+"\n(H="+heur+")",
                            title: heur, //En title guardaremos la heuristica del nodo
	                    	color: "red"
	                    	//label: document.getElementById('node-label').value
	                	});
	                	initial_exists=true;
	                	document.getElementById('cb_initial_node').disabled=true;
	                


                    }else if(!document.getElementById('cb_initial_node').checked && document.getElementById('cb_final_node').checked){ //Si es nodo final
	                	if(!end_nodes_id.includes(document.getElementById('node-id').value)){
	                		end_nodes_id.push(document.getElementById('node-id').value);
	                	}

	                	nodes.update({
	                    	id: document.getElementById('node-id').value,
	                    	label: document.getElementById('node-id').value+"\n(H="+heur+")",
                            title: heur,
                            color: "green"
	                    	//label: document.getElementById('node-label').value
	                	});
	                

                    }else if(document.getElementById('cb_initial_node').checked && document.getElementById('cb_final_node').checked){ // Si quiere que el nodo sea inicial y final a la vez
	                	alert("Un nodo no puede ser inicial y final a la vez");     
	                

                    }else{
	                	nodes.update({
	                   		id: document.getElementById('node-id').value,
	                    	label: document.getElementById('node-id').value+"\n(H="+heur+")",
                            title: heur
	                    	//label: document.getElementById('node-label').value
	                	});
	                }

	                index_nodo=node_ids.indexOf(document.getElementById('node-id').value);
	                node_heuristics[index_nodo]=Number(document.getElementById('node-heuristic').value);


	                if(!eventos_creados){
			        	createNetworkEvents(network);	
			        }
			        printInfo();


	            }
	            catch (err) {
	                alert(err);
	                if(initial_exists){
	                	document.getElementById('cb_initial_node').disabled=true;
	                }else{
	                	document.getElementById('cb_initial_node').disabled=false;
	                }
	            }
	        }

	        
        }











        function removeNode() {
            try {
            	var node_to_remove=document.getElementById('node-id').value;

                nodes.remove({id: node_to_remove});

                if(node_to_remove == initial_node_id){ //He borrado el nodo inicial
                	initial_node_id=null;
                	document.getElementById('cb_initial_node').checked=false;
                	document.getElementById('cb_initial_node').disabled=false;
                	initial_exists=false;
                }

                for (i=0;i<node_ids.length;i++){
	        		if(node_ids[i]==node_to_remove){ 
	        			node_ids.splice(i,1); //Eliminar el nodo del array de id_nodos
	        			node_heuristics.splice(i,1);
	        			break;
	        		}	
        		}

        		//Elimino también todos los edges asociados al nodo
        		var edge_id_splitted;
        		for (i=0;i<edge_ids.length;i++){
        			edge_id_splitted=edge_ids[i].split("_");
        			
        			if(edge_id_splitted[0]==node_to_remove || edge_id_splitted[1]==node_to_remove){
        				edges.remove({id: edge_ids[i]});
					}
        		}



        		if(!eventos_creados){
		        	createNetworkEvents(network);	
		        }
		        printInfo();



            }
            catch (err) {
                alert(err);
            }

            
        }


        function addEdge() {
        	//Obtendo los id de los nodos.
        	node_ids=nodes.getIds();
        	edge_ids=edges.getIds();

        	var src=document.getElementById('edge-from').value;
        	var dst=document.getElementById('edge-to').value;
        	var cost=document.getElementById('edge-cost').value;

        	var valid_src=false;
        	var valid_dst=false;
        	var exists_edge=false;

        	var new_edge_id=""
        	var directed_edge=false;

        	if(document.getElementById('cb_directed_edge').checked){//Vamos a insertar una arista dirigida
        		new_edge_id=src+"_"+dst+"_directed";
                directed_edge=true;
        	}else{ //Vamos a insertar una arista bidireccional
        		new_edge_id=src+"_"+dst+"_normal";
                directed_edge=false;
        	}


            //Miramos que no haya ya una arista entre ambos nodos            
            /*for (i=0;i<edge_ids.length;i++){
                if(edge_ids[i]==dst+"_"+src+"_normal" || edge_ids[i]==src+"_"+dst+"_normal" || edge_ids[i]==dst+"_"+src+"_directed" || edge_ids[i]==src+"_"+dst+"_directed"){
                    alert("Ya hay una arista entre estos dos nodos. Elimínela e introduzca una nueva con los cambios necesarios");
                    exists_edge=true;
                    break;
                }
            }*/

            for (i=0;i<edge_ids.length;i++){
                if(edge_ids[i]==dst+"_"+src+"_normal" || edge_ids[i]==src+"_"+dst+"_normal" || edge_ids[i]==src+"_"+dst+"_directed"){
                    alert("Ya hay una arista entre estos dos nodos. Elimínela e introduzca una nueva con los cambios necesarios");
                    exists_edge=true;
                    break;
                }
            }

            if(!exists_edge){
                //Miramos a ver si los nodos introducidos existen en la lista de nodos
                for (i=0;i<node_ids.length;i++){
                    if(node_ids[i]==src){
                        valid_src=true;
                    }
                    if(node_ids[i]==dst){
                        valid_dst=true;
                    }
                    if(valid_dst&&valid_src){break;}
                }
                try {
                	if(valid_dst&&valid_src){
                		if(directed_edge){ //Si es arista dirigida
                			edges.add({
    		                    //id: document.getElementById('edge-id').value,
    		                    from: src,
    		                    to: dst,
    		                    id: new_edge_id,
    		                    label: Number(cost),
    		                    arrows: "to"
    	                	});
                		}else{
    		                edges.add({ //Si es arista bidireccional
    		                    //id: document.getElementById('edge-id').value,
    		                    from: src,
    		                    to: dst,
                                id: new_edge_id,
    		                    label: Number(cost)
    		                });
    	                }
    	                
                        //document.getElementById('edge-from').value=null;
            			document.getElementById('edge-to').value=null;
            			//document.getElementById('edge-cost').value=null;
    	            }else{
    	            	alert("Uno de los nodos no existe.");
    	            }

    	            if(!eventos_creados){
			        	createNetworkEvents(network);	
			        }
			        printInfo();



                }
                catch (err) {
                    alert(err);
                }
            }

        }










        function updateEdge() {
        	var src=document.getElementById('edge-from').value;
        	var dst=document.getElementById('edge-to').value;
        	var cost=document.getElementById('edge-cost').value;

        	var eid_directed=src+"_"+dst+"_directed";
			var eid_normal=src+"_"+dst+"_normal";
			var correct_id;
			var edge_index=-1;

			var edge_data = edges.get({
			  fields: ['id','from','to','label','arrows'],    // output the specified fields only
			});
			
			for(var i=0;i<edge_data.length;i++){
				if(edge_data[i].id == eid_directed || edge_data[i].id == eid_normal){
					correct_id=edge_data[i].id;		
					edge_index=i;
					break;
				}
			}


            try {
            	if(document.getElementById('cb_directed_edge').checked && correct_id.split("_")[2]=="normal"){ //Era normal y la quiere dirigida
            		edges.add({
	                    from: src,
	                    to: dst,
	                    id: eid_directed,
	                    label: Number(cost),
	                    arrows: "to"
                	});
                	edges.remove({id: correct_id});
            	}else if(!document.getElementById('cb_directed_edge').checked && correct_id.split("_")[2]=="directed"){ //Era dirigida y la quiere normal
            		edges.add({
	                    from: src,
	                    to: dst,
	                    id: eid_normal,
	                    label: Number(cost),
                	});
                	edges.remove({id: correct_id});
            	}else{ //Es normal y la quiere normal o es dirigida y la quiere dirigida, lo unico que quiere es cambiar el coste
            		edges.update({
	                    id: correct_id,
	                    label: Number(cost),
                	});
            	}

            	if(!eventos_creados){
		        	createNetworkEvents(network);	
		        }
		        printInfo();

            }
            catch (err) {
                alert(err);
            }

            
        }




        function removeEdge() {
        	node_ids=nodes.getIds();
        	edge_ids=edges.getIds();

            var src=document.getElementById('edge-from').value;
            var dst=document.getElementById('edge-to').value;

        	var id_to_rm_dir_1=src+"_"+dst+"_directed";
            var id_to_rm_dir_2=dst+"_"+src+"_directed";
        	var id_to_rm_nor_1=src+"_"+dst+"_normal";
        	var id_to_rm_nor_2=dst+"_"+src+"_normal";

            //Elimino cualquier arista que haya entre los dos nodos
            try {
            	for (i=0;i<edge_ids.length;i++){
            		if(edge_ids[i]==id_to_rm_dir_1){
            			edges.remove({id: id_to_rm_dir_1});
            			break;
            		}else if(edge_ids[i]==id_to_rm_nor_1){
            			edges.remove({id: id_to_rm_nor_1});
            			break;
            		}else if(edge_ids[i]==id_to_rm_nor_2){
            			edges.remove({id: id_to_rm_nor_2});
            			break;
            		}else if(edge_ids[i]==id_to_rm_dir_2){
                        edges.remove({id: id_to_rm_dir_2});
                        break;
                    }
            	}


            	if(!eventos_creados){
		        	createNetworkEvents(network);	
		        }
		        printInfo();



            }
            catch (err) {
            	alert(err);
            }
        }














        function updateHeuristics(node_ids_order,new_heuristics_order){
        	try {
	        
	        	var nnodes=nodes.length;

	        	if(new_heuristics_order.length==nnodes){
	        		node_heuristics=new_heuristics_order;
	        		for(var i=0;i<node_ids_order.length;i++){
	        			nodes.update({
	        				id:node_ids_order[i],
	        				title:node_heuristics[i],
	        				label: node_ids_order[i]+"\n(H="+node_heuristics[i]+")",
	        			});
	        		}

	        	}else{
	        		alert("No puede aplicarse esta heuristica");
	        	}

	        	if(!eventos_creados){
		        	createNetworkEvents(network);	
		        }
		        printInfo();
            
            }catch (err) {
            	alert(err);
            }
	        
        }













        function draw() {
            // create an array with nodes
            /*nodes = new vis.DataSet();
            nodes.on('*', function () {
                document.getElementById('nodes').innerHTML = JSON.stringify(nodes.get(), null, 4);
            });
            nodes.add([
                {id: '1', label: 'Node 1'},
                {id: '2', label: 'Node 2'},
                {id: '3', label: 'Node 3'},
                {id: '4', label: 'Node 4'},
                {id: '5', label: 'Node 5'}
            ]);*/

            // create an array with edges
            /*edges = new vis.DataSet();
            edges.on('*', function () {
                document.getElementById('edges').innerHTML = JSON.stringify(edges.get(), null, 4);
            });
            edges.add([
                {id: '1', from: '1', to: '2'},
                {id: '2', from: '1', to: '3'},
                {id: '3', from: '2', to: '4'},
                {id: '4', from: '2', to: '5'}
            ]);*/

            // create a network
            if(typeof(nodes)=='undefined'){
            	nodes = new vis.DataSet();
            }
            if(typeof(edges)=='undefined'){
            	edges = new vis.DataSet();
            }
            var container = document.getElementById('network');
            var data = {
                nodes: nodes,
                edges: edges
            };
            var options = {};
            network = new vis.Network(container, data, options);

            //Obtendo los id de los nodos.
        	node_ids=nodes.getIds();
        	edge_ids=edges.getIds();
        }




        function go_resolution_mode(){
            if(initial_node_id==null){
                alert("Debe haber uno (y solo uno) nodo inicial");
            }else if(end_nodes_id.length==0){
                alert("No existen nodos finales.");
            }else if(edge_ids.length==0){
                alert("No existen aristas.");
            }else{
                //Damos paso a la interfaz de resolucion con jQuery
                $("#principal").fadeOut("slow");
                $("#end-network").fadeOut("slow");
                $("#resolution").fadeIn("slow");
                $("#select-algorithm").fadeIn("fast");
                
                $("#control-buttons").hide();

                $("#edit-network").fadeIn("slow");
                $("#heuristic-generation").hide();
                //adj_mat=getAdjMatrix(edges,node_ids,edge_ids);
                node_ids=nodes.getIds();
                edge_ids=edges.getIds();
                //nodes
                //edges
                //heuristics
                //initial_node_id
                //end_nodes_id
                //edge_cost(es la matriz de adyacencia)

                draw_resolution();
            }
        }

        function edit_network(){
        		$("#control-buttons").hide();
        		$("#select-algorithm").fadeIn("fast");
        		$("#resolution").fadeOut("slow");

        		$("#principal").fadeIn("slow");
                $("#end-network").fadeIn("slow");
                
                $("#edit-network").fadeOut("slow");
                //$("#import-network-input").val("");
                //$("#import-network-div").hide();
                $("#heuristic-generation").hide();
        }
    </script>





    <script type="text/javascript">
        var edge_costs;


        /*function getAdjMatrix(network_edges,node_ids,edge_ids){
            // retrieve formatted items   
            edge_costs = network_edges.get({
              fields: ['label'],    // output the specified fields only
            });

            var adj_matrix = [];
            for(var i=0; i<node_ids.length; i++) {
                adj_matrix[i] = new Array(node_ids.length);
                for(var j=0; j<node_ids.length; j++) {
                    adj_matrix[i][j] = undefined;
                }
            }


            var arista;
            for(var i=0; i<edge_ids.length; i++) {
                arista=edge_ids[i].split("_");
                row=node_ids.indexOf(arista[0]);
                col=node_ids.indexOf(arista[1]);
                adj_matrix[row][col]=Number(edge_costs[i].label);
                if(arista[2]=="normal"){//BIDIRECCIONAL
                    adj_matrix[col][row]=Number(edge_costs[i].label);
                }
            }

            return adj_matrix;
        }*/


        function printInfo(){
        	node_ids=nodes.getIds();
        	edge_ids=edges.getIds();

        	// obtener los costes de los arcos
        	edge_costs = edges.get({
        	  fields: ['label'],    // output the specified fields only
        	});
        	

        	var rest_data_text="Nodos: "+node_ids[0]
        	for (i=1;i<node_ids.length;i++){
        		rest_data_text=rest_data_text+","+node_ids[i];
        	}

        	rest_data_text=rest_data_text+"\nHeuristicas: "+node_heuristics[0];
        	for (i=1;i<node_heuristics.length;i++){
        		rest_data_text=rest_data_text+","+node_heuristics[i];
        	}

        	rest_data_text=rest_data_text+"\nAristas:\n";
        	var arista;
        	for (i=0;i<edge_ids.length;i++){
        		arista=edge_ids[i].split("_");
        		if(arista[2]=="directed"){
        			rest_data_text=rest_data_text+"    de "+arista[0]+" a "+arista[1]+" dirigida con coste "+edge_costs[i].label+"\n";
        		}else if (arista[2]=="normal"){
        			rest_data_text=rest_data_text+"    de "+arista[0]+" a "+arista[1]+" bidireccional con coste "+edge_costs[i].label+"\n";
        		}
        	}

        	rest_data_text=rest_data_text+"Nodo inicial: "+initial_node_id+".\n";
        	rest_data_text=rest_data_text+"Nodo(s) final(es): "+end_nodes_id+".\n";



            document.getElementById('rest-of-data-div').innerHTML = rest_data_text;
        }
    </script>










    <script type="text/javascript">
        function download(filename, text) {
            var element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            element.setAttribute('download', filename);
            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }


        function export_network(){
        	if(is_initial_selected){
        		alert("Por favor, seleccione el nuevo nodo inicial.");
        	}else{
        		if(initial_node_id==null){
	                alert("Debe haber uno (y solo uno) nodo inicial");
	            }else if(end_nodes_id.length==0){
	                alert("No existen nodos finales.");
	            }else if(edge_ids.length==0){
	                alert("No existen aristas.");
	            }else{
		            //Obtengo en string el codigo de los nodos y los edges
		            var code_nodes=nodes.get().toSource();
		            var code_edges=edges.get().toSource();
		            var code_initial_node=initial_node_id;
		            var code_end_nodes=end_nodes_id.toSource();
		            download("grafo.txt",code_nodes+"*-*-*-*-*-*-*-*-*-*-"+code_edges+"*-*-*-*-*-*-*-*-*-*-"+code_initial_node+"*-*-*-*-*-*-*-*-*-*-"+code_end_nodes);
        		}
        	}
        }




        function readSingleFile(evt) {
        	var f = evt.target.files[0];
        	if (f) {
        		var r = new FileReader();
        		r.onload = function(e) {
        			var contents = e.target.result;
        			
					var result=contents.split("*-*-*-*-*-*-*-*-*-*-");
					imported_nodes=result[0];
					imported_edges=result[1];
					imported_initial_node=result[2];
					imported_end_nodes=result[3];

                    if(imported_nodes!=null && imported_edges!=null && imported_initial_node!=null && imported_end_nodes!=null){
                        $("#import-network-btn").prop("disabled",false);
                    }
        		}

        		r.readAsText(f);
        	} else { 
        		alert("Failed to load file");
        	}
        }


        var imported_nodes;
        var imported_edges;
        var imported_initial_node;
        var imported_end_nodes;

        function importNetwork(){
            try{
            	node_heuristics=[];
                nodes = new vis.DataSet();
                edges = new vis.DataSet();
                
                var container = document.getElementById('network');


            	

                //---------------------------------INICIO IMPORTACION DE NODOS---------------------------------//
                var string_nodes=imported_nodes.substr(1, imported_nodes.length-2).split("}, ");
                var nnodes=string_nodes.length;
                var node_color;

                for(var i=0; i<nnodes; i++) {
                    if(i==nnodes-1){
                        string_nodes[i]=string_nodes[i].substr(1, string_nodes[i].length-2);    
                    }else{
                        string_nodes[i]=string_nodes[i].substr(1, string_nodes[i].length-1);
                    }
                    
                    var splitted_by_comma=string_nodes[i].split(",");
                    var nfeatures=splitted_by_comma.length;
                    if(nfeatures<=4){ //Nodos no modificados en color por los eventos de nodo
	                	string_nodes[i]=splitted_by_comma;    

	                    for(var j=0; j<string_nodes[i].length; j++) {
	                        string_nodes[i][j]=string_nodes[i][j].split(":")
	                    }

	                    if(string_nodes[i].length==4){ //Nodo inicial o final
	                    	nodes.add({
	                            id: string_nodes[i][0][1].substr(1,string_nodes[i][0][1].length-2),
	                            label: string_nodes[i][0][1].substr(1,string_nodes[i][0][1].length-2)+"\n(H="+string_nodes[i][2][1]+")",
	                            title: Number(string_nodes[i][2][1]), //Heuristica del nodo
	                            color: string_nodes[i][3][1].substr(1,string_nodes[i][3][1].length-2)
	                        });
	                        
	                        node_heuristics.push(Number(string_nodes[i][2][1]))
	                        
	                    }else if(string_nodes[i].length==3){ // Nodo intermedio
	                        nodes.add({
	                            id: string_nodes[i][0][1].substr(1,string_nodes[i][0][1].length-2),
	                            label: string_nodes[i][0][1].substr(1,string_nodes[i][0][1].length-2)+"\n(H="+string_nodes[i][2][1]+")",
	                            title: Number(string_nodes[i][2][1]) //Heuristica del nodo
	                        });
	                        node_heuristics.push(Number(string_nodes[i][2][1]))
	                    }
	                }else{ //Nodo intermedio modificado por los eventos MODIFICAR AQUI SI SE AÑADEN COSAS AL COLOR EN LOS EVENTOS
	                	string_nodes[i]=string_nodes[i].split("{");
	                	node_color="{"+string_nodes[i][1]+"{"+string_nodes[i][2];

	                	features=string_nodes[i][0].substr(0,string_nodes[i][0].length-1);
	                	features=features.split(",");
	                	features.splice(-1,1); //Elimino el ultimo elemento, la palabra "color"

	                	for(var j=0; j<features.length; j++) {
	                		features[j]=features[j].split(":")[1];
	                	}
	                	
	                	nodes.add({
                            id: features[0].substr(1,features[0].length-2),
                            label: features[0].substr(1,features[0].length-2)+"\n(H="+features[2]+")",
                            title: Number(features[2]) //Heuristica del nodo
                        });
                        node_heuristics.push(Number(features[2]))

	                }

                }
                //-----------------------------------FIN IMPORTACION DE NODOS----------------------------------//

                //---------------------------------INICIO IMPORTACION DE ARISTAS---------------------------------//
                var string_edges=imported_edges.substr(1, imported_edges.length-2).split("}, ");
                var nedges=string_edges.length;
            
                for(var i=0; i<nedges; i++) {
                    if(i==nedges-1){
                        string_edges[i]=string_edges[i].substr(1, string_edges[i].length-2);    
                    }else{
                        string_edges[i]=string_edges[i].substr(1, string_edges[i].length-1);
                    }


                    string_edges[i]=string_edges[i].split(",");

                    for(var j=0; j<string_edges[i].length; j++) {
                        string_edges[i][j]=string_edges[i][j].split(":")
                    }

                    if(string_edges[i].length==4){ //Arista bidireccional 
                        edges.add({
                            from: string_edges[i][0][1].substr(1,string_edges[i][0][1].length-2),
                            to: string_edges[i][1][1].substr(1,string_edges[i][1][1].length-2),
                            id: string_edges[i][2][1].substr(1,string_edges[i][2][1].length-2),
                            label: Number(string_edges[i][3][1])
                        });
                        /*alert(
                            "from:"+ string_edges[i][0][1].substr(1,string_edges[i][0][1].length-2)+",\n"+
                            "to:"+ string_edges[i][1][1].substr(1,string_edges[i][1][1].length-2)+",\n"+
                            "id:"+ string_edges[i][2][1].substr(1,string_edges[i][2][1].length-2)+",\n"+
                            "label:"+ Number(string_edges[i][3][1])
                        );*/
                    }else if(string_edges[i].length==5){ //Arista dirigida
                        edges.add({
                            from: string_edges[i][0][1].substr(1,string_edges[i][0][1].length-2),
                            to: string_edges[i][1][1].substr(1,string_edges[i][1][1].length-2),
                            id: string_edges[i][2][1].substr(1,string_edges[i][2][1].length-2),
                            label: Number(string_edges[i][3][1]),
                            arrows: string_edges[i][4][1].substr(1,string_edges[i][4][1].length-2)
                        });

                        /*alert(
                            "from:"+ string_edges[i][0][1].substr(1,string_edges[i][0][1].length-2)+",\n"+
                            "to:"+ string_edges[i][1][1].substr(1,string_edges[i][1][1].length-2)+",\n"+
                            "id:"+ string_edges[i][2][1].substr(1,string_edges[i][2][1].length-2)+",\n"+
                            "label:"+ Number(string_edges[i][3][1])+",\n"+
                            "arrows:"+ string_edges[i][4][1].substr(1,string_edges[i][4][1].length-2)
                        );*/
                        
                    }

                }
                //-----------------------------------FIN IMPORTACION DE ARISTAS----------------------------------//

                //-----------------------------------IDENTIFICACION NODO INICIAL---------------------------------//
                initial_node_id=imported_initial_node;
                initial_exists=(initial_node_id!=null);
                //---------------------------------FIN IDENTIFICACION NODO INICIAL-------------------------------//


                //----------------------------------IDENTIFICACION NODOS FINALES---------------------------------//
                end_nodes_id=[];
                imported_end_nodes=imported_end_nodes.substr(1,imported_end_nodes.length-2).split(", ");
                for(var i=0; i<imported_end_nodes.length; i++){
                    imported_end_nodes[i]=imported_end_nodes[i].substr(1,imported_end_nodes[i].length-2);
                    end_nodes_id.push(imported_end_nodes[i]);
                }
                //--------------------------------FIN IDENTIFICACION NODOS FINALES-------------------------------//


         

                //alert(getAdjMatrix(edges,node_ids,edge_ids).toSource());

                var data = {
                    nodes: nodes,
                    edges: edges
                };
                var options = {};
                network = new vis.Network(container, data, options);

                //Obtendo los id de los nodos y arcos.
				node_ids=nodes.getIds();
                edge_ids=edges.getIds();                

                if(initial_node_id!="" || initial_node_id!=null){
                    document.getElementById('cb_initial_node').disabled=true;
                }else{
                    document.getElementById('cb_initial_node').disabled=false;
                }

            	createNetworkEvents(network);	
	        	
	        	printInfo();

    			//go_resolution_mode();
            }catch (err) {
                alert("El fichero de entrada no tiene una sintaxis interpretable.")
            }
        }
    </script>
    



    <!--SCRIPT PARA RESOLVER EL GRAFO-->
    <script type="text/javascript">
	    var solution_nodes,solution_edges,solution_network;
	    var index_step=0;

    	function draw_resolution() {
            // create a network
            if(typeof(solution_nodes)=='undefined'){
            	solution_nodes = new vis.DataSet();
            }
            if(typeof(solution_edges)=='undefined'){
            	solution_edges = new vis.DataSet();
            }
            var container = document.getElementById('solution_network');
            var data = {
                nodes: solution_nodes,
                edges: solution_edges
            };
            var options = {};
            solution_network = new vis.Network(container, data, options);

            //Obtendo los id de los nodos.
        	node_ids=nodes.getIds();
        	edge_ids=edges.getIds();
        }


        function draw_resolution_step(network_step){
        	//alert(network_step.toSource());
            solution_nodes = new vis.DataSet();
            solution_edges = new vis.DataSet();
            
            //Meto los nodos del paso actual
            for(var i=0;i<network_step.nodes.length;i++){
            	//alert(network_step.nodes[i].toSource()+" tamanio: "+Object.keys(network_step.nodes[i]).length);
            	if(Object.keys(network_step.nodes[i]).length == 4){//Nodo con atributo color: Inicial, final o intermedio modificado por eventos
            		solution_nodes.add({
                        id: network_step.nodes[i].id,
                        label: network_step.nodes[i].label,
                        title: Number(network_step.nodes[i].title), //Heuristica del nodo
                        color: network_step.nodes[i].color
                    });
            	}else if(Object.keys(network_step.nodes[i]).length == 3){ //Nodo sin atributo color: Nodo intermedio
            		solution_nodes.add({
                        id: network_step.nodes[i].id,
                        label: network_step.nodes[i].label,
                        title: Number(network_step.nodes[i].title) //Heuristica del nodo
                    });
            	}
            }

            //Meto los edges del paso actual
            for(var i=0;i<network_step.edges.length;i++){
            	if(Object.keys(network_step.edges[i]).length == 5){//Nodo con atributo color
            		solution_edges.add({
                        from: network_step.edges[i].from,
                        to: network_step.edges[i].to,
                        id: network_step.edges[i].id,
                        label: network_step.edges[i].label,
                        arrows: network_step.edges[i].arrows
                    });
            	}else{ //Nodo sin atributo color
            		solution_edges.add({
                        from: network_step.edges[i].from,
                        to: network_step.edges[i].to,
                        id: network_step.edges[i].id,
                        label: network_step.edges[i].label
                    });
            	}	
            }

            var container = document.getElementById('solution_network');
            var data = {
                nodes: solution_nodes,
                edges: solution_edges
            };
            var options = {};
            solution_network = new vis.Network(container, data, options);

            //Obtendo los id de los nodos.
        	//node_ids=nodes.getIds();
        	//edge_ids=edges.getIds();*/
        }







        function solveNetwork(){
        	var iter_bound=Number(document.getElementById("max_iter_bound").value);
        	if(initial_node_id==null){
                alert("Debe haber uno (y solo uno) nodo inicial");
            }else if(end_nodes_id.length==0){
                alert("No existen nodos finales.");
            }else if(edge_ids.length==0){
                alert("No existen aristas.");
            }else if(iter_bound<1 || iter_bound>Number(document.getElementById("max_iter_bound").max)){
            	alert("Por favor, introduzca un numero máximo de iteraciones, entre 1 y 1000.");
            }else{
	            var e = document.getElementById("algorithm-select");
	            var strUser = e.options[e.selectedIndex].value;
	            
	            switch(strUser) {
	                case "deep-search":
	                    deep_search(nodes,edges,initial_node_id,end_nodes_id,iter_bound);
	                    document.getElementById("act-estate-algorithm-name").textContent="Estado actual del grafo: Búsqueda en profundidad.";
	                    break;
	                case "astar":
	                    astar(nodes,edges,initial_node_id,end_nodes_id,iter_bound);
	                    document.getElementById("act-estate-algorithm-name").textContent="Estado actual del grafo: A*.";
	                    break;

	               	case "wide-search":
	               		wide_search(nodes,edges,initial_node_id,end_nodes_id,iter_bound);
	                    document.getElementById("act-estate-algorithm-name").textContent="Estado actual del grafo: Búsqueda en anchura.";
	                    break;

					case "retroactive-search":
						retroactive_search(nodes,edges,initial_node_id,end_nodes_id,iter_bound);
						document.getElementById("act-estate-algorithm-name").textContent="Estado actual del grafo: Búsqueda retroactiva.";
	                    break;

					case "iterative-descent":
						iterative_descent(nodes,edges,initial_node_id,end_nodes_id,10,iter_bound);
	                    document.getElementById("act-estate-algorithm-name").textContent="Estado actual del grafo: Descenso iterativo.";
	                    break;

					case "uniform-cost":
						uniform_cost(nodes,edges,initial_node_id,end_nodes_id,iter_bound);
						document.getElementById("act-estate-algorithm-name").textContent="Estado actual del grafo: Búsqueda de coste uniforme (Dijkstra).";
	                    break;


					case "simple-climbing":
						simple_climbing(nodes,edges,initial_node_id,end_nodes_id,iter_bound);
						document.getElementById("act-estate-algorithm-name").textContent="Estado actual del grafo: Escalada simple.";
	                    break;

					case "max-climbing":
						max_climbing(nodes,edges,initial_node_id,end_nodes_id,iter_bound);
						document.getElementById("act-estate-algorithm-name").textContent="Estado actual del grafo: Escalada por la máxima pendiente.";
	                    break;

					/*case "simulated-annealing":
						simulated_annealing(nodes,edges,initial_node_id,end_nodes_id,iter_bound);
						document.getElementById("act-estate-algorithm-name").textContent="Estado actual del grafo: Enfriamiento simulado.";
	                    break;

	                
	                case "test-algorithm":
	                	test_algorithm(nodes,edges,initial_node_id,end_nodes_id,iter_bound);
	                	break;
                    */
	            }

	            $("#select-algorithm").fadeOut("fast");
            	$("#control-buttons").fadeIn("slow");
            	$("#heuristic-generation").hide();
            	index_step=0;
            	document.getElementById('textarea-explanation').value=string_descriptions_steps[index_step];
                document.getElementById('textarea-openclosed').value=open_closed_steps[index_step];
                draw_resolution_step(network_steps[index_step]);

            }
        }



        function solutionStepFordward(){
        	if(index_step<string_descriptions_steps.length-1){
        		index_step+=1;
        		document.getElementById('textarea-explanation').value=string_descriptions_steps[index_step];
        		document.getElementById('textarea-openclosed').value=open_closed_steps[index_step];
        		draw_resolution_step(network_steps[index_step]);
        	}
        }

		function solutionStepBack(){
			if(index_step>0){
        		index_step-=1;
        		document.getElementById('textarea-explanation').value=string_descriptions_steps[index_step];
        		document.getElementById('textarea-openclosed').value=open_closed_steps[index_step];
        		draw_resolution_step(network_steps[index_step]);
        	}
		}

		function solutionFirstStep(){
			if(index_step!=0){
				index_step=0;
				document.getElementById('textarea-explanation').value=string_descriptions_steps[index_step];
				document.getElementById('textarea-openclosed').value=open_closed_steps[index_step];
				draw_resolution_step(network_steps[index_step]);
			}
		}

		function solutionLastStep(){
			var lstep=string_descriptions_steps.length-1;
			if(index_step!=lstep){
				index_step=lstep;
				document.getElementById('textarea-explanation').value=string_descriptions_steps[index_step];
				document.getElementById('textarea-openclosed').value=open_closed_steps[index_step];
				draw_resolution_step(network_steps[index_step]);
			}
		}






        function backToSelectAlgorithm(){
            $("#control-buttons").fadeOut("fast");
            $("#select-algorithm").fadeIn("slow");
            $("#textarea-explanation").val("");
            $("textarea-openclosed").val("");
            $("#heuristic-generation").hide();
        }
    </script>




    <script type="text/javascript">
    function show_div_generate_heuristic(){
    	$("#resolution").fadeOut("slow");
    	$("#heuristic-generation").fadeIn("slow");

    	//$("#control-buttons").hide();
		//$("#select-algorithm").fadeIn("fast");
		//$("#resolution").fadeOut("slow");

		$("#principal").fadeIn("slow");
        $("#end-network").fadeIn("slow");
        
        $("#edit-network").fadeOut("slow");
        //$("#import-network-input").val("");
        //$("#import-network-div").hide();
        //$("#heuristic-generation").hide();
    }


    function generate_heuristic(){
    	if(is_initial_selected){
        		alert("Por favor, seleccione el nuevo nodo inicial.");
    	}else{
    		if(initial_node_id==null){
                alert("Debe haber uno (y solo uno) nodo inicial");
            }else if(end_nodes_id.length==0){
                alert("No existen nodos finales.");
            }else if(edge_ids.length==0){
                alert("No existen aristas.");
            }else{
            	var min_cambios=Number(document.getElementById("min-changes-bound").value);
            	var max_cambios=Number(document.getElementById("max-changes-bound").value);
            	var max_intentos=100;
	            
	            if(min_cambios<=max_cambios && min_cambios>=0){
		            var heuristica_generada=getIdealHeuristic(nodes,edges,initial_node_id,end_nodes_id,min_cambios,max_cambios,max_intentos);
		            if(heuristica_generada!=null){
		            	alert(nodes.getIds().toSource()+"\n"+heuristica_generada.heur.toSource()+".\nEsta heuristica provocará "+heuristica_generada.changes+" actualizaciones en cerrados para el algoritmo A*.");
		            	updateHeuristics(nodes.getIds(),heuristica_generada.heur);
		            	$("#heuristic-generation").fadeOut("slow");
		            }else{
		            	alert("No ha sido posible encontrar una heuristica que cumpla los requisitos.\nPuede probar de nuevo con los mismos parametros. Si no se consigue encontrar la heuristica, debería plantearse cambiar el rango del numero de actualizaciones que desea provocar.");
		            }
	            }else{
	            	alert("El rango de actualizaciones no es válido. El número mínimo de actualizaciones debe ser mayor o igual que 0 y menor o igual que el número máximo");
	            }
    		}
    	}
    }

    </script>

</head>

<body onload="draw();">
<div id="principal">
	<h1>Creación del grafo</h1>


	<div class="desplegable" id="despliegue_dibujar"><a>Dibujar Grafo</a></div>
	<div id="network-form-div">
		<p>Introduzca los parámetros necesarios para crear el grafo. En este modo de creación podemos crear un grafo añadiendo los nodos y las uniones uno a uno.</p>
		<div id="network-form-div-node">
			<h2>Nodo</h2>
			<label for="node-id">Identificador del nodo</label>
			<input id="node-id" type="text" value="">
			
			<br/>				
			
			<label for="node-heuristic">Valor heurístico</label>
			<input id="node-heuristic" type="number" min="0" value="">
			
			<br/>				
			
			<input type="radio" name="initial" id="cb_initial_node" value="initial">Es nodo inicial <br/>
			<input type="radio" name="initial" id="cb_final_node" value="end">Es nodo final<br/>
							
			<button id="node-add" onclick="addNode();">Insertar</button>
			<button id="node-update" onclick="updateNode();">Actualizar</button>
			<button id="node-remove" onclick="removeNode();">Eliminar</button>
		</div>

		<div id="network-form-div-edge">
			<h2>Arista</h2>
										
			<label for="edge-from">Desde</label>
			<input id="edge-from" type="text" value="">
			
			<br/>	
								
			<label for="edge-to">Hasta</label>
			<input id="edge-to" type="text" value="">
			
			<br/>

			<label for="edge-cost">Coste</label>
			<input id="edge-cost" type="number" min="0" value="">
				
			<br/>

			<input type="checkbox" id="cb_directed_edge" value="directed">Es arista dirigida

			<br/>
							
			<button id="edge-add" onclick="addEdge();">Insertar</button>
			<button id="edge-update" onclick="updateEdge();">Actualizar</button>
			<button id="edge-remove" onclick="removeEdge();">Eliminar</button>
		</div>
							
						
	</div>



	<div class="desplegable" id="despliegue_importar"><a>Importar grafo</a></div>
	<div id="import-network-div">
		<p>Importar un archivo. Si previamente exportó un archivo de este generador, puede importarlo desde aquí</p><br/>
		<input type="file" id="import-network-input" name="datafile" size="40"/><br/><br/>
		<button id="import-network-btn" onclick="importNetwork();">Importar grafo</button>
		
	</div>


<!--QUITADOS HASTA AQUI LOS ESPACIOS, BIEN TABULADO-->




</div>

<h1>Datos del grafo</h1>
<table class="view">
    <colgroup>
        <!--<col width="25%">-->
        <col id="col-network-data">
        <col id="col-network-draw">
    </colgroup>
    <tr>
        <!--<td>
            <h2>Matriz de adyacencia</h2>
            <pre id="adj-matrix-div"></pre>
        </td>-->

        <td>
            <h2>Resto de datos</h2>
            <pre id="rest-of-data-div"></pre>
        </td>

        <td>
            <h2>Representación gráfica del grafo</h2>
            <div id="network" class="network_box"></div>
            Los nodos <span class="info_color_ini">rojos</span> indican <span class="info_color_ini">nodos iniciales</span>.<br/>
			Los nodos <span class="info_color_fin">verdes</span> indican <span class="info_color_fin">nodos finales</span>.<br/>
        </td>
    </tr>
</table>

<button id="export-network" onclick="export_network();">Exportar grafo</button>
<button id="generate-heuristic" onclick="show_div_generate_heuristic();">Generar heuristica</button>
<button id="end-network" onclick="go_resolution_mode();">Ir al modo resolver grafo</button>
<button id="edit-network" onclick="edit_network();">Editar grafo</button>





<div id="resolution">
	<h1>RESOLUCION DEL GRAFO</h1>
    <table class="view">
        <colgroup>
            <col id="col-network-actual-estate">
            <col id="col-network-select-algoritm">
            <col id="col-network-control-buttons">
        </colgroup>
        <tr>
            <td>
                <h2 id="act-estate-algorithm-name">Estado actual del grafo</h2>
                <div id="solution_network" class="network_box"></div>
                Los nodos <span class="info_color_ini">rojos</span> indican <span class="info_color_ini">nodos iniciales</span>.<br/>
    			Los nodos <span class="info_color_fin">verdes</span> indican <span class="info_color_fin">nodos finales</span>.<br/>
            </td>

            <td id="select-algorithm">
                <h2>&nbsp;</h2>
                <select id="algorithm-select">
                    <option value="deep-search">Búsqueda en profundidad</option> 				<!--IMPLEMENTADO-->
                    <option value="wide-search">Búsqueda en anchura</option>					<!--IMPLEMENTADO-->
                    <option value="iterative-descent">Descenso iterativo</option>				<!--IMPLEMENTADO-->
                    <option value="astar">A*</option>											<!--IMPLEMENTADO-->
                    <option value="uniform-cost">Búsqueda de costo uniforme (Dijkstra)</option>	<!--IMPLEMENTADO-->
                    <option value="retroactive-search">Búsqueda retroactiva</option>			<!--IMPLEMENTADO-->
                    <option value="simple-climbing">Escalada simple</option>					<!--IMPLEMENTADO-->
                    <option value="max-climbing">Escalada por la máxima pendiente</option>		<!--IMPLEMENTADO-->
                    <!--<option value="simulated-annealing">Enfriamiento simulado</option>
                    <option value="test-algorithm">TEST</option>-->    
                </select>

                <button id="solve-button" onclick="solveNetwork();">Resolver</button><br/>

                <label for="max_iter_bound"> Limite de iteraciones: </label>
                <input id="max_iter_bound" type="number" min="1" max="1000" value="" required>

                <!--Si no ocurre nada al pulsar el bot&oacute;n Resolver, prueba borrando la cach&eacute; del navegador.-->
            </td>


            <td id="control-buttons">
                <h2>&nbsp;</h2>
                <button id="step-fordward" class="algselectionbtn" onclick="solutionStepFordward();">Paso adelante</button>
                <button id="step-back" class="algselectionbtn" onclick="solutionStepBack();">Paso atras</button>
                <button id="go-first-step" class="algselectionbtn" onclick="solutionFirstStep();">Ir al principio</button>
                <button id="go-last-step" class="algselectionbtn" onclick="solutionLastStep();">Ir al final</button><br/>
                <textarea id="textarea-openclosed" rows="5" readonly></textarea><br/>
                <textarea id="textarea-explanation" rows="20" readonly></textarea><br/>
                <button id="go-select-algorithm" onclick="backToSelectAlgorithm();" >Cambiar el algoritmo</button><br/>
            </td>
            
        </tr>
    </table>
</div>


<div id="heuristic-generation">
	<label for="min-changes-bound"> Número minimo de cambios: </label>
	<input id="min-changes-bound" type="number" min="0" max="100" value="" required><br/>
	<label for="max-changes-bound"> Número máximo de cambios: </label>
	<input id="max-changes-bound" type="number" min="0" max="100" value="" required><br/>
	<button id="btn-generate-heuristic" class="algselectionbtn" onclick="generate_heuristic();">Generar heurística</button><br/>
</div>

<br/>
<br/>
<br/>
<br/>
<br/>

<div id="footer">
    José Carlos Martínez Velázquez - Trabajo fin de Grado. Universidad de Granada.
</div>

</body>
</html>